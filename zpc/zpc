#!/usr/bin/env python3
"""
ZPC - Z++ Compiler
Zexis OS iÃ§in Z++ dilini HTML/CSS/JS'e derler
Version: 1.0.0
"""

import sys
import re
import os
from typing import List, Dict, Tuple, Optional
from dataclasses import dataclass
from enum import Enum


class TokenType(Enum):
    """Token tÃ¼rleri"""
    CLASS = "class"
    PUBLIC = "public"
    VOID = "void"
    LET = "let"
    CONST = "const"
    HTML_TAG = "html_tag"
    CSS_RULE = "css_rule"
    JS_STATEMENT = "js_statement"
    APP_LOG = "app_log"
    DECORATOR = "decorator"


@dataclass
class Token:
    """Token veri yapÄ±sÄ±"""
    type: TokenType
    value: str
    line: int
    column: int


@dataclass
class HTMLElement:
    """HTML elementi veri yapÄ±sÄ±"""
    tag: str
    attributes: Dict[str, str]
    content: str
    children: List['HTMLElement']
    self_closing: bool = False
    is_opening: bool = False
    is_closing: bool = False
    raw_html: str = ""
    
    def to_html(self, indent: int = 1) -> str:
        """HTML string'e Ã§evir"""
        if self.raw_html:
            indent_str = "    " * indent
            return indent_str + self.raw_html
        
        indent_str = "    " * indent
        
        # Attribute'larÄ± oluÅŸtur
        attrs = ""
        if self.attributes:
            attrs = " " + " ".join([f'{k}="{v}"' for k, v in self.attributes.items()])
        
        if self.self_closing:
            return f"{indent_str}<{self.tag}{attrs} />"
        else:
            return f"{indent_str}<{self.tag}{attrs}>{self.content}</{self.tag}>"


@dataclass
class CSSRule:
    """CSS kuralÄ± veri yapÄ±sÄ±"""
    selector: str
    properties: Dict[str, str]
    
    def to_css(self, indent: int = 2) -> str:
        """CSS string'e Ã§evir"""
        indent_str = "    " * indent
        result = f"{indent_str}{self.selector} {{\n"
        for prop, value in self.properties.items():
            result += f"{indent_str}    {prop}: {value};\n"
        result += f"{indent_str}}}"
        return result


@dataclass
class JSStatement:
    """JavaScript ifadesi veri yapÄ±sÄ±"""
    code: str
    type: str  # 'variable', 'log', 'expression', etc.
    
    def to_js(self, indent: int = 2) -> str:
        """JavaScript string'e Ã§evir"""
        indent_str = "    " * indent
        return f"{indent_str}{self.code}"


class Lexer:
    """Lexical analyzer - kodu token'lara ayÄ±rÄ±r"""
    
    def __init__(self, content: str):
        self.content = content
        self.position = 0
        self.line = 1
        self.column = 1
        self.tokens: List[Token] = []
    
    def tokenize(self) -> List[Token]:
        """Ä°Ã§eriÄŸi token'lara ayÄ±r"""
        return self.tokens


class Parser:
    """Syntax parser - token'larÄ± parse eder"""
    
    def __init__(self, content: str):
        self.content = content
        self.html_elements: List[HTMLElement] = []
        self.css_rules: List[CSSRule] = []
        self.js_statements: List[JSStatement] = []
        self.errors: List[str] = []
    
    def parse(self) -> bool:
        """Ana parse fonksiyonu"""
        try:
            self._extract_run_block()
            self._extract_css_block()
            return len(self.errors) == 0
        except Exception as e:
            self.errors.append(f"Parse hatasÄ±: {str(e)}")
            return False
    
    def _extract_run_block(self):
        """void run() bloÄŸunu parse et"""
        # void run() bloÄŸunu bul
        run_pattern = r'void\s+run\s*\(\s*\)\s*\{(.*?)\n\s*\}'
        run_match = re.search(run_pattern, self.content, re.DOTALL)
        
        if not run_match:
            self.errors.append("void run() bloÄŸu bulunamadÄ±")
            return
        
        run_content = run_match.group(1)
        
        # TÃ¼m iÃ§eriÄŸi analiz et
        self._parse_run_content(run_content)
    
    def _parse_run_content(self, content: str):
        """run() bloÄŸunun iÃ§eriÄŸini parse et"""
        lines = content.split('\n')
        i = 0
        current_indent = 0
        
        while i < len(lines):
            line = lines[i]
            stripped = line.strip()
            
            if not stripped:
                i += 1
                continue
            
            # HTML etiketi mi?
            if stripped.startswith('<'):
                # Tek satÄ±rlÄ±k mÄ±, Ã§ok satÄ±rlÄ±k mÄ± kontrol et
                if self._is_complete_tag(stripped):
                    # Tek satÄ±rlÄ±k etiket
                    html_elem = self._parse_single_line_html(stripped, i + 1)
                    if html_elem:
                        self.html_elements.append(html_elem)
                else:
                    # Ã‡ok satÄ±rlÄ±k veya aÃ§Ä±lÄ±ÅŸ/kapanÄ±ÅŸ etiketi
                    # Raw HTML olarak ekle
                    html_elem = HTMLElement(
                        tag="",
                        attributes={},
                        content="",
                        children=[],
                        raw_html=stripped
                    )
                    self.html_elements.append(html_elem)
            
            # JavaScript deÄŸiÅŸken tanÄ±mÄ± mÄ±?
            elif stripped.startswith(('let ', 'const ', 'var ')):
                js_stmt = self._parse_js_variable(stripped, i + 1)
                if js_stmt:
                    self.js_statements.append(js_stmt)
            
            # app.log() Ã§aÄŸrÄ±sÄ± mÄ±?
            elif 'app.log(' in stripped:
                js_stmt = self._parse_app_log(stripped, i + 1)
                if js_stmt:
                    self.js_statements.append(js_stmt)
            
            # DiÄŸer JavaScript ifadeleri
            elif any(op in stripped for op in ['=', '+', '-', '*', '/', '(', ')']) and not stripped.startswith('<'):
                js_stmt = JSStatement(
                    code=stripped if stripped.endswith(';') else stripped + ';',
                    type='expression'
                )
                self.js_statements.append(js_stmt)
            
            i += 1
    
    def _is_complete_tag(self, line: str) -> bool:
        """Etiketin tek satÄ±rda tamamlanÄ±p tamamlanmadÄ±ÄŸÄ±nÄ± kontrol et"""
        # <tag>content</tag> veya <tag /> formatÄ±nda mÄ±?
        if re.match(r'<[^>]+>.*?</[^>]+>', line):
            return True
        if re.match(r'<[^>]+/>', line):
            return True
        return False
    
    def _parse_single_line_html(self, line: str, line_num: int) -> Optional[HTMLElement]:
        """Tek satÄ±rlÄ±k HTML elementini parse et"""
        # Self-closing tag mÄ±?
        self_closing_match = re.match(r'<([a-zA-Z0-9]+)([^>]*)/>', line)
        if self_closing_match:
            tag = self_closing_match.group(1)
            attrs_str = self_closing_match.group(2).strip()
            attrs = self._parse_attributes(attrs_str)
            return HTMLElement(
                tag=tag,
                attributes=attrs,
                content="",
                children=[],
                self_closing=True
            )
        
        # Normal tag
        normal_match = re.match(r'<([a-zA-Z0-9]+)([^>]*)>(.*?)</\1>', line)
        if normal_match:
            tag = normal_match.group(1)
            attrs_str = normal_match.group(2).strip()
            content = normal_match.group(3)
            attrs = self._parse_attributes(attrs_str)
            return HTMLElement(
                tag=tag,
                attributes=attrs,
                content=content,
                children=[],
                self_closing=False
            )
        
        # Parse edemediyse raw HTML olarak dÃ¶ndÃ¼r
        return HTMLElement(
            tag="",
            attributes={},
            content="",
            children=[],
            raw_html=line
        )
    
    def _parse_attributes(self, attrs_str: str) -> Dict[str, str]:
        """HTML attribute'larÄ±nÄ± parse et"""
        attrs = {}
        if not attrs_str:
            return attrs
        
        # id="value" veya class="value" formatÄ±nÄ± bul
        attr_pattern = r'([a-zA-Z-]+)\s*=\s*["\']([^"\']*)["\']'
        matches = re.findall(attr_pattern, attrs_str)
        
        for attr_name, attr_value in matches:
            attrs[attr_name] = attr_value
        
        return attrs
    
    def _parse_js_variable(self, line: str, line_num: int) -> Optional[JSStatement]:
        """JavaScript deÄŸiÅŸken tanÄ±mÄ±nÄ± parse et"""
        # let a = 'value' formatÄ±nÄ± parse et
        var_pattern = r'(let|const|var)\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(.+)'
        match = re.match(var_pattern, line)
        
        if match:
            keyword = match.group(1)
            var_name = match.group(2)
            value = match.group(3).strip()
            
            # NoktalÄ± virgÃ¼l yoksa ekle
            if not value.endswith(';'):
                value += ';'
            
            code = f"{keyword} {var_name} = {value}"
            return JSStatement(code=code, type='variable')
        
        return None
    
    def _parse_app_log(self, line: str, line_num: int) -> Optional[JSStatement]:
        """app.log() Ã§aÄŸrÄ±sÄ±nÄ± parse et"""
        # app.log('message') veya app.log(variable) formatÄ±nÄ± parse et
        log_pattern = r"app\.log\((.+?)\)"
        match = re.search(log_pattern, line)
        
        if match:
            content = match.group(1).strip()
            
            # String mi deÄŸiÅŸken mi?
            if content.startswith(("'", '"')):
                # String literal
                code = f"console.log({content});"
            else:
                # DeÄŸiÅŸken veya ifade
                code = f"console.log({content});"
            
            return JSStatement(code=code, type='log')
        
        return None
    
    def _extract_css_block(self):
        """void css.style bloÄŸunu parse et"""
        # void css.style bloÄŸunu bul
        css_pattern = r'void\s+css\.style\s*\{(.*?)\n\s*\}\s*\}'
        css_match = re.search(css_pattern, self.content, re.DOTALL)
        
        if not css_match:
            return
        
        css_content = css_match.group(1)
        
        # CSS kurallarÄ±nÄ± parse et
        self._parse_css_content(css_content)
    
    def _parse_css_content(self, css_content: str):
        """CSS iÃ§eriÄŸini parse et"""
        # Selector { properties } formatÄ±nÄ± bul
        # Ä°Ã§ iÃ§e sÃ¼slÃ¼ parantezleri destekle
        
        lines = css_content.split('\n')
        current_selector = None
        current_properties = {}
        brace_count = 0
        
        for line in lines:
            stripped = line.strip()
            if not stripped:
                continue
            
            # AÃ§Ä±lÄ±ÅŸ sÃ¼slÃ¼ parantezi var mÄ±?
            if '{' in stripped:
                # Selector'Ä± al
                selector = stripped.split('{')[0].strip()
                if selector:
                    current_selector = selector
                    current_properties = {}
                brace_count += stripped.count('{')
            
            # KapanÄ±ÅŸ sÃ¼slÃ¼ parantezi var mÄ±?
            if '}' in stripped:
                brace_count -= stripped.count('}')
                if brace_count == 0 and current_selector:
                    # CSS kuralÄ±nÄ± kaydet
                    if current_properties:
                        css_rule = CSSRule(
                            selector=current_selector,
                            properties=current_properties.copy()
                        )
                        self.css_rules.append(css_rule)
                    current_selector = None
                    current_properties = {}
            
            # Property satÄ±rÄ± mÄ±?
            if ':' in stripped and '{' not in stripped and '}' not in stripped:
                parts = stripped.split(':', 1)
                if len(parts) == 2:
                    prop_name = parts[0].strip()
                    prop_value = parts[1].strip().rstrip(';')
                    if current_selector:
                        current_properties[prop_name] = prop_value


class CodeGenerator:
    """HTML/CSS/JS kod Ã¼reteci"""
    
    def __init__(self, parser: Parser):
        self.parser = parser
        self.html_output = ""
    
    def generate(self) -> str:
        """Final HTML Ã§Ä±ktÄ±sÄ±nÄ± oluÅŸtur"""
        html = []
        
        # DOCTYPE ve HTML baÅŸlangÄ±Ã§
        html.append("<!DOCTYPE html>")
        html.append('<html lang="tr">')
        html.append("<head>")
        html.append('    <meta charset="UTF-8">')
        html.append('    <meta name="viewport" content="width=device-width, initial-scale=1.0">')
        html.append("    <title>Z++ App</title>")
        
        # CSS ekle
        if self.parser.css_rules:
            html.append("    <style>")
            for rule in self.parser.css_rules:
                html.append(rule.to_css(indent=2))
            html.append("    </style>")
        
        html.append("</head>")
        html.append('<body class="app">')
        
        # HTML elementlerini ekle
        for element in self.parser.html_elements:
            html.append(element.to_html(indent=1))
        
        # JavaScript ekle
        if self.parser.js_statements:
            html.append("")
            html.append("    <script>")
            for stmt in self.parser.js_statements:
                html.append(stmt.to_js(indent=2))
            html.append("    </script>")
        
        html.append("</body>")
        html.append("</html>")
        
        self.html_output = "\n".join(html)
        return self.html_output


class ZppCompiler:
    """Ana derleyici sÄ±nÄ±fÄ±"""
    
    def __init__(self, source_file: str):
        self.source_file = source_file
        self.source_code = ""
        self.parser: Optional[Parser] = None
        self.generator: Optional[CodeGenerator] = None
        self.output_file = ""
        self.errors: List[str] = []
        self.warnings: List[str] = []
    
    def compile(self) -> bool:
        """Derleme sÃ¼recini baÅŸlat"""
        # 1. DosyayÄ± oku
        if not self._read_source():
            return False
        
        # 2. SÃ¶zdizimi kontrolÃ¼
        if not self._validate_syntax():
            return False
        
        # 3. Parse et
        if not self._parse():
            return False
        
        # 4. Kod Ã¼ret
        if not self._generate_code():
            return False
        
        # 5. Dosyaya yaz
        if not self._write_output():
            return False
        
        return True
    
    def _read_source(self) -> bool:
        """Kaynak dosyayÄ± oku"""
        try:
            with open(self.source_file, 'r', encoding='utf-8') as f:
                self.source_code = f.read()
            return True
        except FileNotFoundError:
            self.errors.append(f"Dosya bulunamadÄ±: {self.source_file}")
            return False
        except Exception as e:
            self.errors.append(f"Dosya okuma hatasÄ±: {str(e)}")
            return False
    
    def _validate_syntax(self) -> bool:
        """Temel sÃ¶zdizimi kontrolÃ¼"""
        required_patterns = [
            (r'class\s+zpp\s*\{', "class zpp tanÄ±mÄ± bulunamadÄ±"),
            (r'@app\s*\{', "@app bloÄŸu bulunamadÄ±"),
            (r'void\s+run\s*\(\s*\)\s*\{', "void run() metodu bulunamadÄ±"),
        ]
        
        for pattern, error_msg in required_patterns:
            if not re.search(pattern, self.source_code):
                self.errors.append(f"SÃ¶zdizimi hatasÄ±: {error_msg}")
                return False
        
        # SÃ¼slÃ¼ parantez dengesi kontrolÃ¼
        open_braces = self.source_code.count('{')
        close_braces = self.source_code.count('}')
        
        if open_braces != close_braces:
            self.warnings.append(f"SÃ¼slÃ¼ parantez dengesi: {open_braces} aÃ§Ä±lÄ±ÅŸ, {close_braces} kapanÄ±ÅŸ")
        
        return True
    
    def _parse(self) -> bool:
        """Kaynak kodu parse et"""
        self.parser = Parser(self.source_code)
        success = self.parser.parse()
        
        if not success:
            self.errors.extend(self.parser.errors)
            return False
        
        return True
    
    def _generate_code(self) -> bool:
        """Kod Ã¼ret"""
        if not self.parser:
            self.errors.append("Parser baÅŸlatÄ±lmamÄ±ÅŸ")
            return False
        
        self.generator = CodeGenerator(self.parser)
        try:
            self.generator.generate()
            return True
        except Exception as e:
            self.errors.append(f"Kod Ã¼retim hatasÄ±: {str(e)}")
            return False
    
    def _write_output(self) -> bool:
        """Ã‡Ä±ktÄ± dosyasÄ±nÄ± yaz"""
        if not self.generator:
            self.errors.append("Kod Ã¼reteci baÅŸlatÄ±lmamÄ±ÅŸ")
            return False
        
        self.output_file = self.source_file.replace('.zpp', '.html')
        
        try:
            with open(self.output_file, 'w', encoding='utf-8') as f:
                f.write(self.generator.html_output)
            return True
        except Exception as e:
            self.errors.append(f"Dosya yazma hatasÄ±: {str(e)}")
            return False
    
    def print_stats(self):
        """Derleme istatistiklerini yazdÄ±r"""
        if not self.parser:
            return
        
        print(f"\nğŸ“Š Derleme Ä°statistikleri:")
        print(f"   HTML Elementleri: {len(self.parser.html_elements)}")
        print(f"   CSS KurallarÄ±: {len(self.parser.css_rules)}")
        print(f"   JavaScript Ä°fadeleri: {len(self.parser.js_statements)}")
        
        if self.warnings:
            print(f"\nâš ï¸  {len(self.warnings)} UyarÄ±:")
            for warning in self.warnings:
                print(f"   - {warning}")


def print_banner():
    """BaÅŸlÄ±k banner'Ä± yazdÄ±r"""
    banner = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      ZPC - Z++ Compiler v1.0.0       â•‘
â•‘    Zexis OS Development Tool         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""
    print(banner)


def print_usage():
    """KullanÄ±m bilgisi"""
    usage = """
KullanÄ±m:
    zpc <dosya.zpp>              Tek dosya derle
    zpc <dosya.zpp> -v           DetaylÄ± Ã§Ä±ktÄ± ile derle
    zpc --help                   Bu yardÄ±m mesajÄ±nÄ± gÃ¶ster
    zpc --version                Versiyon bilgisi

Ã–rnekler:
    zpc app.zpp                  app.zpp dosyasÄ±nÄ± derler
    zpc myproject.zpp -v         DetaylÄ± mod ile derler
"""
    print(usage)


def main():
    """Ana fonksiyon"""
    # ArgÃ¼man kontrolÃ¼
    if len(sys.argv) < 2:
        print_banner()
        print("âŒ Hata: Dosya belirtilmedi!\n")
        print_usage()
        sys.exit(1)
    
    # YardÄ±m
    if sys.argv[1] in ['--help', '-h']:
        print_banner()
        print_usage()
        sys.exit(0)
    
    # Versiyon
    if sys.argv[1] in ['--version', '-v']:
        print_banner()
        sys.exit(0)
    
    input_file = sys.argv[1]
    verbose = '-v' in sys.argv or '--verbose' in sys.argv
    
    # Dosya kontrolÃ¼
    if not os.path.exists(input_file):
        print(f"âŒ Hata: '{input_file}' dosyasÄ± bulunamadÄ±!")
        sys.exit(1)
    
    if not input_file.endswith('.zpp'):
        print("âŒ Hata: Sadece .zpp dosyalarÄ± derlenebilir!")
        sys.exit(1)
    
    # Banner
    if verbose:
        print_banner()
    
    print(f"ğŸ”§ Derleniyor: {input_file}")
    
    # Derle
    compiler = ZppCompiler(input_file)
    success = compiler.compile()
    
    # SonuÃ§larÄ± gÃ¶ster
    if success:
        print(f"âœ… Derleme baÅŸarÄ±lÄ±: {compiler.output_file}")
        if verbose:
            compiler.print_stats()
    else:
        print(f"\nâŒ Derleme baÅŸarÄ±sÄ±z! {len(compiler.errors)} hata bulundu:\n")
        for i, error in enumerate(compiler.errors, 1):
            print(f"   {i}. {error}")
        sys.exit(1)


if __name__ == "__main__":
    main()
